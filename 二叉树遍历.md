- 144. 二叉树前序遍历
- 94. 二叉树中序遍历
- 145. 二叉树后序遍历


## 144. 二叉树前序遍历

![](https://i.loli.net/2020/07/27/Q2boUZfrxFWVlv8.jpg)

递归方法
```javascript
var preorderTraversal = function(root) {
    var result = [];
    
    preorder(root);
    
    return result;
    
    function preorder(root) {
        if (root !== null) {
            result.push(root.val);
            preorder(root.left);
            preorder(root.right);
        }
    }
};
```

非递归方法，利用栈
```javascript
var preorderTraversal = function(root) {
    var result = [];
    var stack = [];
    
    var node = root;
    // 当遍历到最后一个节点的时候，它的左右子树都为空，并且栈也为空
    // 所以，只要不同时满足这两点，都需要进入循环
    while(stack.length !== 0 || node != null){
        while(node != null){// 由考查顺序得知，需要一直往左走
            result.push(node.val);
            stack.push(node);
            node = node.left;
        }
        if(stack.length !== 0) {// 一直到左子树为空，则开始考虑右子树
            node = stack.pop();// 弹出栈顶元素，将游标等于该节点的右子树
            node = node.right;
        }
    }
    
    return result;
};
```

## 94. 二叉树中序遍历

非递归方法，利用栈

```javascript
var inorderTraversal = function(root) {
    var stack = [];
    var result = [];
    
    var node = root;
    // 当遍历到最后一个节点的时候，它的左右子树都为空，并且栈也为空
    // 所以，只要不同时满足这两点，都需要进入循环
    while(stack.length !== 0 || node != null){
        while(node != null){// 由考查顺序得知，需要一直往左走
            stack.push(node);
            node = node.left;
        }
        if(stack.length !== 0){// 一直到左子树为空，则开始考虑右子树
            node = stack.pop();// 弹出栈顶元素，将游标等于该节点的右子树
            result.push(node.val);
            node = node.right;
        }
    }
    
    return result;
};
```

## 145. 二叉树后序遍历

非递归方法，利用栈

```javascript
var postorderTraversal = function(root) {
    var stack = [];
    var result = [];
    
    var node = root;
    var lastVisited = root;
    // 当遍历到最后一个节点的时候，它的左右子树都为空，并且栈也为空
    // 所以，只要不同时满足这两点，都需要进入循环
    while(stack.length !== 0 || node != null){
        while(node != null){// 由考查顺序得知，需要一直往左走
            stack.push(node);//一直到该节点的左边节点为空
            node = node.left;
        }
        node = stack[stack.length-1];//查看当前栈顶元素，看这个节点右边是不是空的，或者是右边访问过了
        if(node.right == null || node.right == lastVisited){//如果其右子树为空或已经访问,则可以直接输出当前节点的值，否则，继续遍历右子树
            result.push(node.val);
            stack.pop();
            lastVisited = node;
            node = null; //这里置空是为了防止重复遍历
        }else{//否则，继续遍历右子树
            node = node.right;
        }
    }
    
    return result;
};
```